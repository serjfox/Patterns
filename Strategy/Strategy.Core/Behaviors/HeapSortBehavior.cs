namespace Strategy.Core.Behaviors
{
    public class HeapSortBehavior : IStrategyBehavior
    {
        // O(n log n)
        public void ExecuteOperation(int[] array)
        {
            int n = array.Length;

            // Создаём из массива сортирующее дерево
            // Максимальный элемент окажется в корне
            for (int k = array.Length / 2; k > 0; k--)
                DownHeap(array, k, array.Length);

            // Избавляемся от максимумов 
            // и перетряхиваем сортирующее дерево
            do
            {
                // Меняем максимум с последним элементом...
                Swap(array, n);

                // ... и перестравиваем сортирующее дерево
                // для неотсортированной части массива			
                n -= 1;
                DownHeap(array, 1, n);

            } while (n > 1); //До последнего элемента

        }

        private static void Swap(int[] array, int n)
        {
            var tmp = array[0];
            array[0] = array[n - 1];
            array[n - 1] = tmp;
        }

        // Просматриваем ветку и в её корень перемещаем наибольший узел
        void DownHeap(int[] array, int k, int n)
        {
            // В корне поддерева
            // запоминаем родителя
            int tmp = array[k - 1];

            // Смотрим потомков в пределах ветки
            while (k <= n / 2)
            {
                var j = k + k; // Левый потомок

                // Если есть правый потомок, 
                // то сравниваем его с левым
                // и из них выбираем наибольший
                if ((j < n) && (array[j - 1] < array[j]))
                    j++;

                // Если родитель больше (или равен) наибольшего потомка...
                if (tmp >= array[j - 1])
                {
                    // ... то значит всё в порядке в этой ветке		
                    break;
                }
                else
                // Если родитель меньше наибольшего потомка...	
                {
                    // ... то потомок становится на место родителя
                    array[k - 1] = array[j - 1];
                    k = j;
                }
            }

            // Родитель в итоге меняется местами с наибольшим из потомков
            // (или остаётся на своём месте, если все потомки меньше его)
            array[k - 1] = tmp;
        }
    }
}